/**
 * @file    i2c.c
 * @brief   Driver functions to implement I2C functionalities of read, write, sequential read
 * 			and generating all the necessary conditions to satisfy the protocol
 *
 * @author	Venkat Sai Krishna Tata
 * @Reference Alexander Dean, Textbook- Chapter 8 Serial Communication
 * 			Textbook: Embedded Systems Fundamentals with ARM Cortex-M based Microcontrollers
 * @Date	05/02/2021
 */

//INCLUDES
#include <MKL25Z4.H>
#include <stdint.h>
#include "i2c.h"

//MACROS
#define RESET (0)
#define PRESCALE_64 (0x10)
#define I2C_SCL_PIN (24)
#define I2C_SDA_PIN (25)
#define I2C_PORT (5)

/*
 * @Name		i2c_start_bit
 * @Description	On toggling the MST bit from 0 to 1, the START condition is generated  by the master
 * 				and reflects on the SCL and SDA lines. Also, the Master mode is set
 *
 * @parameters	none
 * @Returns		none
 */
static void i2c_start_bit()
{
	//Setting the Master bit to generate START condition
	I2C0->C1 |= I2C_C1_MST_MASK;
}

/*
 * @Name		i2c_stop_bit
 * @Description	On toggling the MST bit from 1 to , the STOP condition is generated by the master
 * 				and reflects on the SCL and SDA lines.
 *
 * @parameters	none
 * @Returns		none
 */
static void i2c_stop_bit()
{
	//Clearing the Master bit to generate STOP condition
	I2C0->C1 &= ~(I2C_C1_MST_MASK);
}

/*
 * @Name		i2c_repeated_start
 * @Description	When the KL25Z is in master mode, on setting the RSTA mask , a repeated start
 * 				bit is generated and reflects on the SDA and SCL lines
 *
 * @parameters	none
 * @Returns		none
 */
static void i2c_repeated_start()
{
	//Setting the repeated start (RSTA) bit to generate repeated START condition
	//If set at a wrong time, causes the loss of bus arbitration
	I2C0->C1 |= I2C_C1_RSTA_MASK;
}

/*
 * @Name		begin_transmit
 * @Description	Sets the direction of transfer to be from Master to slave, for address
 * 				cycles, this bit is always set
 *
 * @parameters	none
 * @Returns		none
 */
static void begin_transmit()
{
	//Setting the bit to enable transmission from Master to Slave
	I2C0->C1 |= I2C_C1_TX_MASK;
}

/*
 * @Name		begin_recieve
 * @Description	Sets the direction of transfer to be from Slave to Master, then the Master
 * 				receives data from slave
 *
 * @parameters	none
 * @Returns		none
 */
static void begin_recieve()
{
	//Setting the bit to enable reception from Slave to Master
	I2C0->C1 &= ~(I2C_C1_TX_MASK);
}

/*
 * @Name		i2c_send_ack_bit
 * @Description	On reception of a byte of data, Master sends an ACK requesting more bytes
 *
 * @parameters	none
 * @Returns		none
 */
static void i2c_send_ack_bit()
{
	//Clearing the bit TXAK enables an acknowledge on reception of byte of data
	I2C0->C1 &= ~(I2C_C1_TXAK_MASK);
}

/*
 * @Name		i2c_send_nack_bit
 * @Description	On reception of a byte of data, Master does not send an ACK indicating that
 * 				was the last byte master wanted to read
 *
 * @parameters	none
 * @Returns		none
 */
static void i2c_send_nack_bit()
{
	//Setting the TXAK bit causes no acknowledge to be sent on reception of a byte of data
	I2C0->C1 |= I2C_C1_TXAK_MASK;
}

/*
 * @Name		tx_addr_read
 * @Description	Transmits the byte with the LSB set indicating that the Master wants to
 * 				read from the device which is input as argument
 *
 * @parameters	uint8_t - Address of the device from which the Master wants to read
 * @Returns		none
 */
static void tx_addr_read(uint8_t dev_addr)
{
	//Transmits the device address with the Write bit or LSB set indicating that it wants to
	//read from slave. This is done by setting the LSB of the device address byte.
	I2C0->D = (dev_addr|0x1);
}

/*
 * @Name		tx_addr_write
 * @Description	Write the address/data provided as argument with the write bit set low
 *
 * @parameters	uint8_t - Address of the device to which the Master wants to write
 * @Returns		none
 */
static void tx_addr_write(uint8_t dev_addr)
{
	//Transmits the device address with the Write bit or LSB low indicating that its a
	//write to slave
	I2C0->D = (dev_addr);
}

/*
 * @Name		i2c_rx_slave_data
 * @Description	Reads the data at the I/O register which was received from the slave
 * 				and returns to the caller function
 *
 * @parameters	none
 * @Returns		uint8_t - the data read from the data I/O register
 */
static uint8_t i2c_rx_slave_data()
{
	//Return the data in the Data register
	return I2C0->D;
}

/*
 * See documentation in .h file
 */
void init_I2C()
{
	//Clock gating to enable clock to peripheral I2C0 and port E
	SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK;
	SIM->SCGC5 |= (SIM_SCGC5_PORTE_MASK);

	//Initialize as the alternate functions for the I2C clock and data pins
	PORTE->PCR[I2C_SCL_PIN] |= PORT_PCR_MUX(I2C_PORT);
	PORTE->PCR[I2C_SDA_PIN] |= PORT_PCR_MUX(I2C_PORT);

	//Reset the frequency divider register and pre-scale it with 64
	//so that the I2C module is operated in the standard I2C mode of 100 kHz
	I2C0->F = RESET;
 	I2C0->F = (I2C_F_ICR(PRESCALE_64));

	//Enable the I2C module as the master
	I2C0->C1 |= (I2C_C1_IICEN_MASK | I2C_C1_MST_MASK );

	//Sets the I2C pads in high drive mode
	I2C0->C2 |= I2C_C2_HDRS_MASK;
}

/*
 * See documentation in .h file
 */
void i2c_ack_wait()
{
	//On completion of transfer or reception of slave, the bit is set
	while(((I2C0->S & I2C_S_IICIF_MASK)==0));

	//Before the next transmission, the bit is cleared manually, to allow transfer/reception
	I2C0->S |= I2C_S_IICIF_MASK;
}

/*
 * See documentation in .h file
 */
void i2c_start_seq()
{
	//Set KL25Z as master and begin transmission and immediately generate the start condition
	begin_transmit();
	i2c_start_bit();
}

/*
 * See documentation in .h file
 */

void i2c_read_addr(uint8_t dev_addr, uint8_t location)
{
	//Transmit the device address as a write operation to write the location
	//and wait until transfer completes and ACK is sent
	tx_addr_write(dev_addr);
	i2c_ack_wait();

	//Transmit the location from which the master wants to read data from and wait
	//until transfer completes and an ACK is received
	tx_addr_write(location);
	i2c_ack_wait();

	//Generate a repeated start to transmit the device address with the Read bit set
	//Indicating the master wants to start the read operation, wait until ACK is
	//received
	i2c_repeated_start();
	tx_addr_read(dev_addr);
	i2c_ack_wait();

	//begin reading the data from Data I/O register which contains data sent by the slave
	begin_recieve();

}

/*
 * See documentation in .h file
 */

uint8_t i2c_read_reg(uint8_t tx_ack)
{
	//A byte to store the data received from the slave
	uint8_t rx_byte;

	//If this is not the last byte to be read, send NACK
	//else send ACK bit indicating end of read operation
	if(!tx_ack)
	{
		i2c_send_nack_bit();
	}
	else
	{
		i2c_send_ack_bit();
	}
	
	//perform a dummy read to initiate receiving the next byte of data and wait until
	//reception of data is complete
	rx_byte = i2c_rx_slave_data();
	i2c_ack_wait();

	//If this is the last bit, along with NACK , also send the stop bit to end the operation
	if(!tx_ack)
	{
		i2c_stop_bit();
	}
	//The data stored in the Data I/O register is the data requested by master, retrieve and
	//return the data
	rx_byte = i2c_rx_slave_data();
	return  rx_byte;
}

/*
 * See documentation in .h file
 */
uint8_t i2c_rxByte(uint8_t dev_addr, uint8_t location)
{
	//A byte to store the data received from the slave
	uint8_t rx_byte;

	//Set KL25Z as master and begin transmission and immediately generate the start condition
	i2c_start_seq();

	//Transmit the device address as a write operation to write the location
	//and wait until transfer completes and ACK is sent
	tx_addr_write(dev_addr);
	i2c_ack_wait();

	//Transmit the location from which the master wants to read data from and wait
	//until transfer completes and an ACK is received
	tx_addr_write(location);
	i2c_ack_wait();

	//Generate a repeated start to transmit the device address with the Read bit set
	//Indicating the master wants to start the read operation, wait until ACK is received
	i2c_repeated_start();
	tx_addr_read(dev_addr);
	i2c_ack_wait();

	//begin reading the data from Data I/O register which contains data sent by the slave
	//and send NACK bit to indicate end of read operation
	begin_recieve();
	i2c_send_nack_bit();
	
	//perform a dummy read to initiate receiving the next byte of data and wait until
	//reception of data is complete
	rx_byte = i2c_rx_slave_data();
	i2c_ack_wait();

	//Transmit the stop bit to indicate end of operation and retrieve the data stored in
	//the Data I/O register which is data sent by the slave and return the data
	i2c_stop_bit();
	rx_byte = i2c_rx_slave_data();

	return rx_byte;
}

/*
 * See documentation in .h file
 */
void i2c_txByte(uint8_t dev_addr, uint8_t reg_addr, uint8_t txbyte)
{
	//Set KL25Z as master and begin transmission and immediately generate the start condition
	i2c_start_seq();
	
	//Write the device address onto the SDA line and wait the slave to provide an acknowledgment
	tx_addr_write(dev_addr);
	i2c_ack_wait();

	//Transmit the control register address/location in the slave to which the following data byte
	//is to be written and wait for an acknowledgment
	tx_addr_write(reg_addr);
	i2c_ack_wait();

	//Transmit the data byte value and wait for an acknowledgment from the slave
	tx_addr_write(txbyte);
	i2c_ack_wait();

	//Once the transfer is complete, the write operation is stopped by generating a STOP condition
	i2c_stop_bit();
	
}
